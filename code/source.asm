; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG19354 DB	'LearnOpenGL', 00H
	ORG $+4
$SG19356 DB	'Failes to create GLFW window :(', 00H
$SG19358 DB	'Failed fo initialize GLEW', 00H
CONST	ENDS
PUBLIC	?key_callback@@YAXPEAUGLFWwindow@@HHHH@Z	; key_callback
PUBLIC	main
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3e99999a
PUBLIC	__real@3f800000
EXTRN	__imp_glClear:PROC
EXTRN	__imp_glClearColor:PROC
EXTRN	__imp_glViewport:PROC
EXTRN	glewInit:PROC
EXTRN	glfwInit:PROC
EXTRN	glfwTerminate:PROC
EXTRN	glfwWindowHint:PROC
EXTRN	glfwCreateWindow:PROC
EXTRN	glfwWindowShouldClose:PROC
EXTRN	glfwSetWindowShouldClose:PROC
EXTRN	glfwGetFramebufferSize:PROC
EXTRN	glfwPollEvents:PROC
EXTRN	glfwSetKeyCallback:PROC
EXTRN	glfwMakeContextCurrent:PROC
EXTRN	glfwSwapBuffers:PROC
EXTRN	printf:PROC
EXTRN	glewExperimental:BYTE
EXTRN	_fltused:DWORD
pdata	SEGMENT
$pdata$?key_callback@@YAXPEAUGLFWwindow@@HHHH@Z DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$?key_callback@@YAXPEAUGLFWwindow@@HHHH@Z
$pdata$main DD	imagerel $LN7
	DD	imagerel $LN7+334
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
xdata	SEGMENT
$unwind$?key_callback@@YAXPEAUGLFWwindow@@HHHH@Z DD 011701H
	DD	04217H
$unwind$main DD	010401H
	DD	08204H
xdata	ENDS
; Function compile flags: /Odtp
; File w:\code\source.cpp
_TEXT	SEGMENT
height$ = 48
width$ = 52
window$ = 56
main	PROC

; 18   : {

$LN7:
	sub	rsp, 72					; 00000048H

; 19   :     glfwInit();

	call	glfwInit

; 20   :     glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);

	mov	edx, 3
	mov	ecx, 139266				; 00022002H
	call	glfwWindowHint

; 21   :     glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);

	mov	edx, 3
	mov	ecx, 139267				; 00022003H
	call	glfwWindowHint

; 22   :     glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

	mov	edx, 204801				; 00032001H
	mov	ecx, 139272				; 00022008H
	call	glfwWindowHint

; 23   :     glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);

	xor	edx, edx
	mov	ecx, 131075				; 00020003H
	call	glfwWindowHint

; 24   : 
; 25   :     GLFWwindow *window = glfwCreateWindow(WIDTH, HEIGHT, "LearnOpenGL", nullptr, nullptr);

	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	lea	r8, OFFSET FLAT:$SG19354
	mov	edx, 600				; 00000258H
	mov	ecx, 800				; 00000320H
	call	glfwCreateWindow
	mov	QWORD PTR window$[rsp], rax

; 26   :     if(window == nullptr)

	cmp	QWORD PTR window$[rsp], 0
	jne	SHORT $LN4@main

; 27   :     {
; 28   :         printf("Failes to create GLFW window :(");

	lea	rcx, OFFSET FLAT:$SG19356
	call	printf

; 29   :         glfwTerminate();

	call	glfwTerminate

; 30   :         return -1;

	mov	eax, -1
	jmp	$LN5@main
$LN4@main:

; 31   :     }
; 32   :     glfwMakeContextCurrent(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	glfwMakeContextCurrent

; 33   : 
; 34   :     glfwSetKeyCallback(window, key_callback);

	lea	rdx, OFFSET FLAT:?key_callback@@YAXPEAUGLFWwindow@@HHHH@Z ; key_callback
	mov	rcx, QWORD PTR window$[rsp]
	call	glfwSetKeyCallback

; 35   : 
; 36   :     
; 37   :     glewExperimental = GL_TRUE;

	mov	BYTE PTR glewExperimental, 1

; 38   :     if(glewInit() != GLEW_OK)

	call	glewInit
	test	eax, eax
	je	SHORT $LN3@main

; 39   :     {
; 40   :         printf("Failed fo initialize GLEW");

	lea	rcx, OFFSET FLAT:$SG19358
	call	printf

; 41   :         return -1;

	mov	eax, -1
	jmp	SHORT $LN5@main
$LN3@main:

; 42   :     }
; 43   :     
; 44   : 
; 45   :     int width, height;
; 46   :     glfwGetFramebufferSize(window, &width, &height);

	lea	r8, QWORD PTR height$[rsp]
	lea	rdx, QWORD PTR width$[rsp]
	mov	rcx, QWORD PTR window$[rsp]
	call	glfwGetFramebufferSize

; 47   : 
; 48   :     glViewport(0, 0, width, height);

	mov	r9d, DWORD PTR height$[rsp]
	mov	r8d, DWORD PTR width$[rsp]
	xor	edx, edx
	xor	ecx, ecx
	call	QWORD PTR __imp_glViewport
$LN2@main:

; 49   :     
; 50   : 
; 51   :     
; 52   :     while(!glfwWindowShouldClose(window))

	mov	rcx, QWORD PTR window$[rsp]
	call	glfwWindowShouldClose
	test	eax, eax
	jne	SHORT $LN1@main

; 53   :     {
; 54   :         glfwPollEvents();

	call	glfwPollEvents

; 55   : 
; 56   :         glClearColor(0.2f, 0.3f, 0.3f, 1.0f);

	movss	xmm3, DWORD PTR __real@3f800000
	movss	xmm2, DWORD PTR __real@3e99999a
	movss	xmm1, DWORD PTR __real@3e99999a
	movss	xmm0, DWORD PTR __real@3e4ccccd
	call	QWORD PTR __imp_glClearColor

; 57   :         glClear(GL_COLOR_BUFFER_BIT);

	mov	ecx, 16384				; 00004000H
	call	QWORD PTR __imp_glClear

; 58   :         
; 59   :         glfwSwapBuffers(window);

	mov	rcx, QWORD PTR window$[rsp]
	call	glfwSwapBuffers

; 60   :     }

	jmp	SHORT $LN2@main
$LN1@main:

; 61   :     
; 62   :     
; 63   :     glfwTerminate();

	call	glfwTerminate

; 64   :     return 0;

	xor	eax, eax
$LN5@main:

; 65   : }

	add	rsp, 72					; 00000048H
	ret	0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File w:\code\source.cpp
_TEXT	SEGMENT
window$ = 48
key$ = 56
scancode$ = 64
action$ = 72
mode$ = 80
?key_callback@@YAXPEAUGLFWwindow@@HHHH@Z PROC		; key_callback

; 10   : {

$LN4:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 11   :     if(key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)

	cmp	DWORD PTR key$[rsp], 256		; 00000100H
	jne	SHORT $LN1@key_callba
	cmp	DWORD PTR action$[rsp], 1
	jne	SHORT $LN1@key_callba

; 12   :         glfwSetWindowShouldClose(window, GL_TRUE);

	mov	edx, 1
	mov	rcx, QWORD PTR window$[rsp]
	call	glfwSetWindowShouldClose
$LN1@key_callba:

; 13   : }

	add	rsp, 40					; 00000028H
	ret	0
?key_callback@@YAXPEAUGLFWwindow@@HHHH@Z ENDP		; key_callback
_TEXT	ENDS
END
